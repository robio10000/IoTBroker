using IoTBroker.Domain;
using IoTBroker.Features.Clients;
using IoTBroker.Features.Rules;
using IoTBroker.Infrastructure.Data;
using Microsoft.EntityFrameworkCore;

namespace IoTBroker.Features.Sensors;

public class SensorService : ISensorService
{
    private readonly IApiKeyService _apiKeyService;
    private readonly IoTContext _context;
    private readonly ILogger<SensorService> _logger;
    private readonly IRuleService _ruleService;

    //private readonly ConcurrentDictionary<string, List<SensorPayload>> _store = new();

    public SensorService(ILogger<SensorService> logger, IApiKeyService apiKeyService, IRuleService ruleService,
        IoTContext context)
    {
        _logger = logger;
        _apiKeyService = apiKeyService;
        _ruleService = ruleService;
        _context = context;
    }

    /// <summary>
    ///     Get all sensor payloads, optionally filtered by client ID
    /// </summary>
    /// <param name="clientId">The client ID to filter by (optional)</param>
    /// <returns>Enumerable of all sensor payloads</returns>
    public async Task<IEnumerable<SensorPayload>> GetAll(string? clientId)
    {
        // If no clientId is provided, return all payloads
        if (clientId == null)
            return await _context.Payloads
                .OrderByDescending(x => x.Timestamp)
                .ToListAsync();

        // Filter payloads by clientId
        return await _context.Payloads
            .Where(p => p.DeviceId.StartsWith(clientId + "_"))
            .OrderByDescending(x => x.Timestamp)
            .ToListAsync();
    }

    /// <summary>
    ///     Get the latest sensor payload by device ID
    /// </summary>
    /// <param name="clientId">The client ID</param>
    /// <param name="id">The sensor device id</param>
    /// <returns>The latest sensor payload or null if not found</returns>
    public async Task<SensorPayload?> GetById(string clientId, string id)
    {
        var internalKey = GetInternalKey(clientId, id);

        return await _context.Payloads
            .Where(p => p.DeviceId == internalKey)
            .OrderByDescending(p => p.Timestamp)
            .FirstOrDefaultAsync();
    }

    /// <summary>
    ///     Get the full history of sensor payloads by device ID
    /// </summary>
    /// <param name="clientId">The client ID</param>
    /// <param name="id">The sensor device id</param>
    /// <returns>Enumerable of sensor payloads</returns>
    public async Task<IEnumerable<SensorPayload>> GetHistoryById(string clientId, string id)
    {
        var internalKey = GetInternalKey(clientId, id);

        return await _context.Payloads
            .Where(p => p.DeviceId == internalKey)
            .OrderByDescending(p => p.Timestamp)
            .ToListAsync();
    }

    /// <summary>
    ///     Check if a device ID exists in the store
    /// </summary>
    /// <param name="clientId">The client ID</param>
    /// <param name="id">The sensor id</param>
    /// <returns>True if exists, false otherwise</returns>
    public async Task<bool> Exists(string clientId, string id)
    {
        var internalKey = GetInternalKey(clientId, id);
        return await _context.Payloads.AnyAsync(p => p.DeviceId == internalKey);
    }

    /// <summary>
    ///     Delete a device history by ID
    /// </summary>
    /// <param name="clientId">The client ID</param>
    /// <param name="id">The sensor id</param>
    /// <returns>True if deleted, false otherwise</returns>
    public async Task<bool> Delete(string clientId, string id)
    {
        var internalKey = GetInternalKey(clientId, id);
        var payloads = await _context.Payloads.Where(p => p.DeviceId == internalKey).ToListAsync();
        if (!payloads.Any()) return false;
        _context.Payloads.RemoveRange(payloads);
        await _context.SaveChangesAsync();
        return true;
    }

    /// <summary>
    ///     Process and store the sensor payload
    /// </summary>
    /// <param name="clientId">The client ID submitting the payload</param>
    /// <param name="payload">The sensor payload</param>
    /// <param name="isGeneratedByRule">Indicates if the payload was generated by a rule</param>
    /// <returns>ServiceResult indicating success or failure</returns>
    public async Task<ServiceResult> ProcessPayload(string clientId, SensorPayload payload,
        bool isGeneratedByRule = false)
    {
        // 1. Validation of the payload
        var validation = ValidateValue(payload);
        if (!validation.Success)
        {
            _logger.LogWarning(
                $"Payload validation failed for device {payload.DeviceId} by client {clientId}: {validation.Message}");
            return validation;
        }

        // 2. Save history
        _context.Payloads.Add(payload);

        // 3. Ensure the device is registered to the client
        _apiKeyService.AddDeviceToClient(clientId, payload.DeviceId);

        // 4. Get or create the device history list
        var state = await _context.DeviceStates
            .FirstOrDefaultAsync(s => s.ClientId == clientId && s.DeviceId == payload.DeviceId);

        // 5. Update or create the current device state
        if (state == null)
        {
            _context.DeviceStates.Add(new DeviceState
            {
                ClientId = clientId,
                DeviceId = payload.DeviceId,
                Value = payload.Value,
                Type = payload.Type,
                LastUpdate = DateTime.UtcNow
            });
        }
        else
        {
            state.Value = payload.Value;
            state.LastUpdate = DateTime.UtcNow;
        }

        if (!isGeneratedByRule) await _ruleService.ExecuteRules(clientId, payload);

        _logger.LogInformation($"Data processed for device {payload.DeviceId} by client {clientId}.");
        await _context.SaveChangesAsync();
        return new ServiceResult(true);
    }

    /// <summary>
    ///     Validate the sensor payload value based on its type
    /// </summary>
    /// <param name="payload">The sensor payload</param>
    /// <returns>ServiceResult indicating validation success or failure</returns>
    private ServiceResult ValidateValue(SensorPayload payload)
    {
        switch (payload.Type)
        {
            case SensorType.Numeric:
                return double.TryParse(payload.Value, out _)
                    ? new ServiceResult(true)
                    : new ServiceResult(false, "Value is not a valid number.");
            case SensorType.Boolean:
                return bool.TryParse(payload.Value, out _)
                    ? new ServiceResult(true)
                    : new ServiceResult(false, "Value is not a valid boolean.");
            case SensorType.String:
                return new ServiceResult(true);
            default:
                return new ServiceResult(false, "Unknown sensor type.");
        }
    }

    /// <summary>
    ///     Generate an internal key for storage based on client and device IDs
    /// </summary>
    /// <param name="clientId">The client ID</param>
    /// <param name="deviceId">The device ID</param>
    /// <returns>Internal storage key</returns>
    private string GetInternalKey(string clientId, string deviceId)
    {
        return $"{clientId}_{deviceId}";
    }
}